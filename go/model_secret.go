/*
 * Secret Server
 *
 * This is an API of a secret service. You can save your secret by using the API. You can restrict the access of a secret after the certen number of views or after a certen period of time.
 *
 * API version: 1.0.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"time"

	_ "github.com/lib/pq"
)

var db *sql.DB

type Secret struct {

	// Unique hash to identify the secrets
	Hash string `json:"hash,omitempty"`

	// The secret itself
	SecretText string `json:"secretText,omitempty"`

	// The date and time of the creation
	CreatedAt time.Time `json:"createdAt,omitempty"`

	// The secret cannot be reached after this time
	ExpiresAt time.Time `json:"expiresAt,omitempty"`

	// How many times the secret can be viewed
	RemainingViews int `json:"remainingViews,omitempty"`
}

type Secrets []Secret

func ConnectDB() {
	connStr := "user=letoan dbname=secret_server_api sslmode=disable"
	conn, err := sql.Open("postgres", connStr)
	handleErr(err)
	err = conn.Ping()
	if err != nil {
		log.Fatal("Error: Could not establish a connection with the database")
	} else {
		log.Printf("Connected to Secret Server API database ")
	}
	db = conn
}

func Create(sc Secret) (rs string) {
	createQuery := `INSERT INTO secret(hash, secrettext, createdat, expiresat, remainingviews) VALUES ($1, $2, $3, $4, $5) RETURNING hash;`
	hash := string("")
	fmt.Println(sc)
	err := db.QueryRow(createQuery, sc.Hash, sc.SecretText, sc.CreatedAt, sc.ExpiresAt, sc.RemainingViews).Scan(&hash)
	handleErr(err)
	return hash
}

func GetSecrets() Secrets {
	// queryStmt, err := db.Prepare

	rows, err := db.Query("SELECT * FROM secret;")
	handleErr(err)
	defer rows.Close()
	Secrets := Secrets{}
	for rows.Next() {
		Secret := Secret{}
		// var name string
		// if err := rows.Scan(&name); err != nil {
		// 	log.Fatal(err)
		// }
		// names = append(names, name)
		err = rows.Scan(
			&Secret.Hash,
			&Secret.SecretText,
			&Secret.CreatedAt,
			&Secret.ExpiresAt,
			&Secret.RemainingViews,
		)
		handleErr(err)

		// b, err := json.Marshal()
		// if err != nil {
		// 	fmt.Println(err)
		// 	return
		// }
		// fmt.Println(string(b))

		Secrets = append(Secrets, Secret)
	}
	return Secrets

}

func Show(hash string) (rs string) {
	secret := Secret{}
	selectQuery := "SELECT hash, secrettext, createdat, expiresat, remainingviews FROM secret WHERE hash = $1 AND expiresat > $2 AND remainingviews > 0 ;"
	err := db.QueryRow(selectQuery, hash, time.Now()).Scan(&secret.Hash, &secret.SecretText, &secret.CreatedAt, &secret.ExpiresAt, &secret.RemainingViews)
	if err != nil {
		return string("not found")
	}

	(&secret).decreaseRemainingViewsBy1()
	resultJSON, err := json.Marshal(secret)
	handleErr(err)
	return string(resultJSON)

}

func (s *Secret) decreaseRemainingViewsBy1() {
	(*s).RemainingViews--
	updateQuery := "UPDATE public.secret SET remainingviews=$1 WHERE hash = $2;"
	err := db.QueryRow(updateQuery, (*s).RemainingViews, (*s).Hash)
	if err == nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

func handleErr(err error) {
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}
